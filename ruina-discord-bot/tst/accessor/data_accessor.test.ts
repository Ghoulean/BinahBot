import { Localization, LookupResult } from "@ghoulean/ruina-common";
import { DataAccessor } from "../../src/accessor/data_accessor";

const PEACE_EN_PAGE_NAME = "Peace";
const PEACE_EN_PAGE_NAME_TYPO = "Peacc";
const PEACE_PAGE_ID = "ApocalypseBird_Atk";
const JUDGEMENT_PAGE_ID = "980311";
const BAMBOO_HATTED_KIM_PAGE_ID = "243003";
const INCOMPLETE_ARBITER_PASSIVE_ID = "10011";


const GOODBYE_KR_NAME = "Good Bye";

const AUTOCOMPLETE_QUERY = "The Bea";

const BAD_PAGE_NAME = "PageNameThatDoesNotExist";
const BAD_PAGE_ID = "PageIdThatDoesNotExist";

let dataAccessor: DataAccessor;

beforeEach(() => {
    dataAccessor = new DataAccessor();
});

test("should return lookup result when given page name and locale", () => {
    expect(
        dataAccessor.lookup(PEACE_EN_PAGE_NAME, Localization.ENGLISH)
    ).toMatchSnapshot();
    expect(
        dataAccessor.lookup(GOODBYE_KR_NAME, Localization.KOREAN)
    ).toMatchSnapshot();
});

test("should fuzzy match results if query is close", () => {
    expect(
        dataAccessor.lookup(
            PEACE_EN_PAGE_NAME_TYPO,
            Localization.ENGLISH
        )
    ).toMatchSnapshot();
});

test("should return lookup result even if preferred locale is not available", () => {
    expect(
        dataAccessor.lookup(PEACE_EN_PAGE_NAME, Localization.KOREAN)
    ).toMatchSnapshot();
});

test("should throw error when given bad lookup request", () => {
    expect(() => {
        dataAccessor.lookup(BAD_PAGE_NAME, Localization.ENGLISH);
    }).toThrow();
});

test("should return decorated abno page result when given page id and locale", () => {
    expect(
        dataAccessor.getDecoratedAbnoPage(
            PEACE_PAGE_ID,
            Localization.ENGLISH
        )
    ).toMatchSnapshot();
});

test("should throw error when given bad decorated abno page request", () => {
    expect(() => {
        dataAccessor.getDecoratedAbnoPage(BAD_PAGE_ID, Localization.ENGLISH);
    }).toThrow();
});

test("should return decorated combat page result when given page id and locale", () => {
    expect(
        dataAccessor.getDecoratedCombatPage(
            JUDGEMENT_PAGE_ID,
            Localization.ENGLISH
        )
    ).toMatchSnapshot();
});

test("should throw error when given bad decorated combat page request", () => {
    expect(() => {
        dataAccessor.getDecoratedCombatPage(BAD_PAGE_ID, Localization.ENGLISH);
    }).toThrow();
});

test("should return decorated key page result when given page id and locale", () => {
    expect(
        dataAccessor.getDecoratedKeyPage(
            BAMBOO_HATTED_KIM_PAGE_ID,
            Localization.ENGLISH
        )
    ).toMatchSnapshot();
});

test("should throw error when given bad decorated key page request", () => {
    expect(() => {
        dataAccessor.getDecoratedKeyPage(BAD_PAGE_ID, Localization.ENGLISH);
    }).toThrow();
});


test("should return decorated passive result when given page id and locale", () => {
    expect(
        dataAccessor.getDecoratedPassive(
            INCOMPLETE_ARBITER_PASSIVE_ID,
            Localization.ENGLISH
        )
    ).toMatchSnapshot();
});

test("should throw error when given bad decorated passive request", () => {
    expect(() => {
        dataAccessor.getDecoratedPassive(BAD_PAGE_ID, Localization.ENGLISH);
    }).toThrow();
});

test("should return disambiguation page result when given page id", () => {
    // Need to retrieve disambiguation page because disambig IDs
    // are autogenerated at each build
    const salvationDisambiguation: LookupResult = dataAccessor.lookup(
        "Salvation",
        Localization.ENGLISH
    );
    const salvationDisambiguationPageId = salvationDisambiguation.pageId;
    expect({
        ...dataAccessor.getDisambiguationResult(salvationDisambiguationPageId),
        id: "",
    }).toMatchSnapshot();
});

test("should throw error when given bad disambiguation page request", () => {
    expect(() => {
        dataAccessor.getDisambiguationResult(BAD_PAGE_ID);
    }).toThrow();
});

test("should return autocomplete result when given query", () => {
    expect(dataAccessor.autocomplete(AUTOCOMPLETE_QUERY)).toMatchSnapshot();
});
